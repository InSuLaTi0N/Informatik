/*
    方法(Method)在执行过程中, 在JVM中的内存分配情况以及内存变化情况
        1. 方法只定义, 不调用 是不会执行的, 且不会给该方法分配"运行所属"的内存空间.
            只有在调用这个方法时, 才会动态地给该方法分配所属内存空间
        2. 在JVM内存划分上有三块主要内存空间:
            - 方法区内存
            -堆内存
            -栈内存
        3. 关于栈数据结构:
            栈(stack) 是一种数据结构
            数据结构反应数据的存储形态
            数据结构(Datenstructure) 是独立学科
            常见数据结构:
                数组
                队列
                栈
                链表
                二叉树
                哈希表
                ...
        4. 关于方法执行:
            -方法代码片段属于.class字节码文件的一部分, 字节码文件在类加载时将其放置在了方法区当中, 因此
             JVM的三块主要内存空间中方法区内存最先有数据, 存放了代码片段
             
            -代码片段只在方法区内存中有一份, 但是可以重复调用
             每次调用该方法时, 需要给该方法分配独立的活动场所, 在栈内存中分配. 
            -栈内存中分配方法运行的所属内存空间
        5. 方法在调用的瞬间会给该方法分配独立的内存空间, 会在栈中发生压栈动作, 方法执行结束之后, 
           给该方法分配的内存空间全部释放, 此时发生弹栈动作
           
           -压栈: 给该方法分配内存
           -弹栈: 释放该方法内存空间
           
        6. 局部变量在方法体中声明, 局部变量运行阶段内存在栈中分配
        
    重点: 方法调用的时候, 在参数传递时, 实际上传递的是变量保存的那个值
    栈内存主要存储局部变量
*/

public class Method{
    
    public static void main(String[] args){ //1.首先在栈内存中为main方法开出了内存空间
        int a = 10; //2.10这个值被命名为a变量
        int b = 20;
        int retValue = sumInt(a, b); //3.跳入sumInt方法  此处仅执行至=右边 还未执行复制动作  等=右边执行完毕进行赋值
        // 13. sumInt出栈 在main方法中开出值为10的空间, 命名为retValue
        System.out.println("retValue = " + retValue)
        
    }
    
    public static int sumInt(int i, int j){ //4.开辟sumInt方法的内存空间.i 的实参为a, 此处传递的是10, 并不是a
        int result = i + j; //5.此处由cpu进行运算  并在sumInt方法中开出一个值为30的空间 命名为result
        int num = 3; // 6.开出值为3的空间  命名为num
        int retValue = divide(result, num); //7.sumInt转为不活跃(暂停)状态  因为此处调用divide方法 divide发生入栈
        //11. 此时divide出栈, 在sumInt方法中开辟出值为10的空间, 命名为retValue
        return retValue; //12. 返回10(retValue的值), 并将它赋给main方法的retValue
    }
    
    public static int divide(int x, int y){ //8.参数传递, 30传入x, 3传入y
        int z = x / y; //9.cpu运算 开出值为10的空间, 命名为z
        return z; //10.返回10  返回后将10赋给sumInt方法中的retValue
    }
}

/*
    内存分析, 画图依据:
        -只要涉及参数传递的问题, 传递的是变量中保存的值
        -画图的时候必须遵循方法自上而下的顺序依次执行
        
    画图方法:
        -程序执行一步, 在图上体现一步即可
*/